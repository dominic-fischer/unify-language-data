SYSTEM PROMPT:
You are an expert in the italian language. You excel at inspecting linguistic data from different sources and distilling them into a specific format.

USER PROMPT:
You are a linguist tasked with normalizing grammatical descriptions for the language italian.

The data you receive comes from multiple sources and relates to the following topics:
negation, syntax.

Your goal is to transform the data into a structure that EXACTLY matches the reference schema provided.

REFERENCE SCHEMA (structure and headings must be followed exactly):
{
  "$schema": "http://json-schema.org/draft/2020-12/schema",
  "title": "Grammar File Schema",
  "type": "object",

  "$defs": {
    "endings": {
      "type": "object",
      "properties": {
        "features": { "type": "object" },
        "form": { "type": "string" },
        "note": { "type": "string" }
      },
      "required": ["features", "form"]
    },
    "forms": {
      "type": "object",
      "properties": {
        "features": { "type": "object" },
        "form": { "type": "string" },
        "pattern": { "type": "string" },
        "note": { "type": "string" }
      },
      "required": ["features"],
      "oneOf": [
        { "required": ["form"] },
        { "required": ["pattern"] }
      ]
    },
    "applies": {
      "type": "object",
      "description": "Feature-value constraints for the rule/usage"
    },
    "examples": {
      "type": "array",
      "items": { "type": "string" },
      "minItems": 1
    },
    "patterns": {
      "type": "object",
      "properties": {
        "pattern": { "type": "string" },
        "examples": { "$ref": "#/$defs/examples" },
        "note": { "$ref": "#/$defs/note" },
        "endings": {
          "type": "array",
          "items": { "$ref": "#/$defs/endings" }
        },
        "forms": {
          "type": "array",
          "items": { "$ref": "#/$defs/forms" }
        }
      },
      "oneOf": [
        { "required": ["pattern"] },
        { "required": ["forms"] }
      ]
    },
    "note": {
      "type": "string"
    }
  },

  "patternProperties": {
    "^[A-Z][A-Za-z0-9-]*$": {
      "type": "object",
      "required": ["Features", "Rules"],
      "properties": {
        "Features": {
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": { "type": "string" }
          }
        },
        "Usage": {
          "type": "object",
          "additionalProperties": {
            "type": "object",
            "properties": {
              "applies": { "$ref": "#/$defs/applies" },
              "note": { "$ref": "#/$defs/note" },
              "examples": { "$ref": "#/$defs/examples" }
            },
            "anyOf": [
              { "required": ["applies"] },
              { "required": ["note"] },
              { "required": ["examples"] }
            ]
          }
        },
        "Negation": {
          "type": "object",
          "required": ["examples"],
          "properties": {
            "pattern": { "type": "string" },
            "examples": { "$ref": "#/$defs/examples" },
            "note": { "$ref": "#/$defs/note" }
          }
        },
        "Rules": {
          "type": "object",
          "additionalProperties": {
            "type": "object",
            "required": ["applies"],
            "properties": {
              "applies": { "$ref": "#/$defs/applies" },
              "pattern": { "type": "string" },
              "patterns": {
                "type": "array",
                "items": { "$ref": "#/$defs/patterns" }
              },
              "endings": {
                "type": "array",
                "items": { "$ref": "#/$defs/endings" }
              },
              "forms": {
                "type": "array",
                "items": { "$ref": "#/$defs/forms" }
              },
              "examples": { "$ref": "#/$defs/examples" },
              "note": { "$ref": "#/$defs/note" },
              "negation": { "type": "string" }
            },
            "anyOf": [
              { "required": ["pattern"], "not": { "required": ["patterns"] } },
              { "required": ["patterns"], "not": { "anyOf": [ { "required": ["pattern"] }, { "required": ["forms"] } ] } },
              { "required": ["forms"], "not": { "required": ["patterns"] } }
            ]
          }
        },
        "Notes": {
          "type": "array",
          "items": { "type": "string" }
        }
      }
    }
  },

  "additionalProperties": false
}

INSTRUCTIONS:
- Use ONLY the information present in the provided data.
- Rephrase content where necessary, but do NOT add new facts.
- Merge overlapping information into a single coherent description.
- Ignore information that is not relevant to the reference schema.
- Preserve the hierarchy and ordering of the reference schema.

FEATURES AND THEIR VALUES:
- Feature names and values are prefixed with either u-, x- or it-.
- Use the prefix "u-" for UniMorph features and values.
- Use the prefix "x-" for custom (non-UniMorph, cross-linguistic) features and values.
- Use the language prefix "italian-" ONLY for language-specific features and values.
- When multiple representations are possible, prefer:
  1) UniMorph ("u-") features,
  2) then custom ("x-") features,
  3) and only then language-specific ("italian-") features.
- Do NOT invent new features if an appropriate UniMorph feature exists.

SOURCE DATA:
Source 1:
Italian is an SVO language. Nevertheless, the SVO sequence is sometimes replaced by one of the other arrangements (SOV, VSO, OVS, etc.), especially for reasons of emphasis and, in literature, for reasons of style and metre: Italian has relatively free word order.
The subject is usually omitted when it is a pronoun—distinctive verb conjugations make it redundant. Subject pronouns are considered emphatic when used at all.
Questions are formed by a rising intonation at the end of the sentence (in written form, a question mark). There is usually no other special marker, although wh-movement does usually occur. In general, intonation and context are important to recognize questions from affirmative statements.

## Syntax > ### Table 45

<pre>```
| 0                                    | 1                                                                                                                                  |
|:-------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------|
| Davide è arrivato in ufficio.        | ("David has arrived at the office.")                                                                                               |
| Davide è arrivato in ufficio?        | ("Talking about David… did he arrive at the office?" or "Davide has arrived at the office? Really?" – depending on the intonation) |
| Perché Davide è arrivato in ufficio? | ("Why has David arrived at the office?")                                                                                           |
| Perché Davide è arrivato in ufficio. | ("Because David has arrived at the office.")                                                                                       |
| È arrivato Davide in ufficio.        | ("It was David who arrived at the office" or "David arrived at the office" – depending on the intonation)                          |
| È arrivato Davide in ufficio?        | ("Has David arrived at the office?")                                                                                               |
| È arrivato in ufficio.               | ("He has arrived at the office.")                                                                                                  |
| (Lui) è arrivato in ufficio.         | ("He has arrived at the office.")                                                                                                  |
| Chi è arrivato in ufficio?           | ("Who has arrived at the office?")                                                                                                 |
```</pre>


In general, adjectives come after the noun they modify, adverbs after the verb. But: as with French, adjectives coming before the noun indicate essential quality of the noun. Demonstratives (e.g. questo, 'this', quello, 'that') come before the noun, and a few particular adjectives (e.g. bello) may be inflected like demonstratives and placed before the noun.

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 



EXAMPLE OUTPUT (for German):
Negation:
  Features:
    x-Negation-type: [x-clause, x-constituent]

  Rules:
    x-Negation-type_x-constituent:
      applies: {x-Negation-type: x-constituent}
      patterns: 
        - pattern: "nicht + constituent"
          examples: 
          - "Er rennt nicht heute"
          - "Nicht das Essen, sondern die Getränke hat er bezahlt"
          note: "focuses on constituent rather than whole sentence"
        - pattern: "kein + noun"
          examples: 
          - "Ich habe keinen Hund gesehen"
          note: "negates indefinite noun phrase; inflected like indefinite determiner"

    x-Negation-type_x-clause:
      applies: {x-Negation-type: x-clause}
      patterns: 
      - pattern: "(...) finite/main verb (...) nicht (...) (final verb cluster)"
        examples: 
        - "Er will den Kuchen nicht essen"
        - "Er rennt heute nicht"
        note: "Negated main clauses."
      - pattern: "main clause with Vfin, subordinating conjunction (...) nicht (...) final verb cluster"
        examples: 
        - "Er geht nach Hause, weil er nicht in der Schule bleiben will"
        - "..., weil er in der Schule jeden Tag nicht gut aufpasst"
        - "..., weil er in der Schule nicht jeden Tag gut aufpasst"
        note: "Negated subclauses."
      note: "If the entire sentence is to be negated, 'nicht' goes as far to the end as possible, but before the final verb cluster/the constituent it is supposed to negate. Note that for main- and subclauses, the principle of negation (finite/main verb - negation - final verb cluster) stays the same, apart from the subordinating conjunction intervening."


OUTPUT RULES:
- Output ONLY the synthesized schema.
- Do NOT include explanations, comments, or metadata.
- Use the same formatting style as the example.

